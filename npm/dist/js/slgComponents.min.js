angular.module('slgComponents', []);

console.log("slgComponents v.0.0.32");

function slgGetValueFromNestedObject(obj, paramString) {
	var names = paramString.split('.');

	var nextObj = obj;
	for (i = 0; i < names.length; i++)
		nextObj = obj[names[i]];

	return nextObj;
}

function slgGuid() {
	function s4() {
		return Math.floor((1 + Math.random()) * 0x10000)
				   .toString(16)
				   .substring(1);
	}
	return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
		   s4() + '-' + s4() + s4() + s4();
}

function slgGetStyle(oElm, strCssRule) {
	var strValue = "";
	if (document.defaultView && document.defaultView.getComputedStyle) {
		strValue = document.defaultView.getComputedStyle(oElm, "").getPropertyValue(strCssRule);
	}
	else if (oElm.currentStyle) {
		strCssRule = strCssRule.replace(/\-(\w)/g, function (strMatch, p1) {
			return p1.toUpperCase();
		});
		strValue = oElm.currentStyle[strCssRule];
	}
	return strValue;
}

//fgnass.github.com/spin.js#v1.2.5
/**
 * Copyright (c) 2011 Felix Gnass [fgnass at neteye dot de]
 * Licensed under the MIT license
 */

var prefixes = ['webkit', 'Moz', 'ms', 'O']; /* Vendor prefixes */
var animations = {}; /* Animation rules keyed by their name */
var useCssAnimations;

/**
 * Utility function to create elements. If no tag name is given,
 * a DIV is created. Optionally properties can be passed.
 */
function createEl(tag, prop) {
	var el = document.createElement(tag || 'div');
	var n;

	for (n in prop) {
		el[n] = prop[n];
	}
	return el;
}

/**
 * Appends children and returns the parent.
 */
function ins(parent /* child1, child2, ...*/) {
	for (var i = 1, n = arguments.length; i < n; i++) {
		parent.appendChild(arguments[i]);
	}
	return parent;
}

/**
 * Insert a new stylesheet to hold the @keyframe or VML rules.
 */
var sheet = function () {
	var el = createEl('style');
	ins(document.getElementsByTagName('head')[0], el);
	return el.sheet || el.styleSheet;
}();

/**
 * Creates an opacity keyframe animation rule and returns its name.
 * Since most mobile Webkits have timing issues with animation-delay,
 * we create separate rules for each line/segment.
 */
function addAnimation(alpha, trail, i, lines) {
	var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-');
	var start = 0.01 + i / lines * 100;
	var z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha);
	var prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase();
	var pre = prefix && '-' + prefix + '-' || '';

	if (!animations[name]) {
		sheet.insertRule(
		  '@' + pre + 'keyframes ' + name + '{' +
		  '0%{opacity:' + z + '}' +
		  start + '%{opacity:' + alpha + '}' +
		  (start + 0.01) + '%{opacity:1}' +
		  (start + trail) % 100 + '%{opacity:' + alpha + '}' +
		  '100%{opacity:' + z + '}' +
		  '}', 0);
		animations[name] = 1;
	}
	return name;
}

/**
 * Tries various vendor prefixes and returns the first supported property.
 **/
function vendor(el, prop) {
	var s = el.style;
	var pp;
	var i;

	if (s[prop] !== undefined) return prop;
	prop = prop.charAt(0).toUpperCase() + prop.slice(1);
	for (i = 0; i < prefixes.length; i++) {
		pp = prefixes[i] + prop;
		if (s[pp] !== undefined) return pp;
	}
}

/**
 * Sets multiple style properties at once.
 */
function css(el, prop) {
	for (var n in prop) {
		el.style[vendor(el, n) || n] = prop[n];
	}
	return el;
}

/**
 * Fills in default values.
 */
function merge(obj) {
	for (var i = 1; i < arguments.length; i++) {
		var def = arguments[i];
		for (var n in def) {
			if (obj[n] === undefined) obj[n] = def[n];
		}
	}
	return obj;
}

/**
 * Returns the absolute page-offset of the given element.
 */
function pos(el) {
	var o = { x: el.offsetLeft, y: el.offsetTop };
	while ((el = el.offsetParent)) {
		o.x += el.offsetLeft;
		o.y += el.offsetTop;
	}
	return o;
}

var defaults = {
	lines: 12,            // The number of lines to draw
	length: 7,            // The length of each line
	width: 5,             // The line thickness
	radius: 10,           // The radius of the inner circle
	rotate: 0,            // rotation offset
	color: '#000',        // #rgb or #rrggbb
	speed: 1,             // Rounds per second
	trail: 100,           // Afterglow percentage
	opacity: 1 / 4,         // Opacity of the lines
	fps: 20,              // Frames per second when using setTimeout()
	zIndex: 2e9,          // Use a high z-index by default
	className: 'slgSpinner', // CSS class to assign to the element
	top: 'auto',          // center vertically
	left: 'auto'          // center horizontally
};

/** The constructor */
var slgSpinner = function slgSpinner(o) {
	if (!this.spin) return new slgSpinner(o);
	this.opts = merge(o || {}, slgSpinner.defaults, defaults);
};

slgSpinner.defaults = {};
merge(slgSpinner.prototype, {
	spin: function (target) {
		this.stop();
		var self = this;
		var o = self.opts;
		var el = self.el = css(createEl(0, { className: o.className }), { position: 'relative', zIndex: o.zIndex });
		var mid = o.radius + o.length + o.width;
		var ep; // element position
		var tp; // target position

		if (target) {
			target.insertBefore(el, target.firstChild || null);
			tp = pos(target);
			ep = pos(el);
			css(el, {
				left: (o.left == 'auto' ? tp.x - ep.x + (target.offsetWidth >> 1) : o.left + mid) + 'px',
				top: (o.top == 'auto' ? tp.y - ep.y + (target.offsetHeight >> 1) : o.top + mid) + 'px'
			});
		}

		el.setAttribute('aria-role', 'progressbar');
		self.lines(el, self.opts);

		if (!useCssAnimations) {
			// No CSS animation support, use setTimeout() instead
			var i = 0;
			var fps = o.fps;
			var f = fps / o.speed;
			var ostep = (1 - o.opacity) / (f * o.trail / 100);
			var astep = f / o.lines;

			!function anim() {
				i++;
				for (var s = o.lines; s; s--) {
					var alpha = Math.max(1 - (i + s * astep) % f * ostep, o.opacity);
					self.opacity(el, o.lines - s, alpha, o);
				}
				self.timeout = self.el && setTimeout(anim, ~~(1000 / fps));
			}();
		}
		return self;
	},
	stop: function () {
		var el = this.el;
		if (el) {
			clearTimeout(this.timeout);
			if (el.parentNode) el.parentNode.removeChild(el);
			this.el = undefined;
		}
		return this;
	},
	lines: function (el, o) {
		var i = 0;
		var seg;

		function fill(color, shadow) {
			return css(createEl(), {
				position: 'absolute',
				width: (o.length + o.width) + 'px',
				height: o.width + 'px',
				background: color,
				boxShadow: shadow,
				transformOrigin: 'left',
				transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.radius + 'px' + ',0)',
				borderRadius: (o.width >> 1) + 'px'
			});
		}
		for (; i < o.lines; i++) {
			seg = css(createEl(), {
				position: 'absolute',
				top: 1 + ~(o.width / 2) + 'px',
				transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
				opacity: o.opacity,
				animation: useCssAnimations && addAnimation(o.opacity, o.trail, i, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
			});
			if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), { top: 2 + 'px' }));
			ins(el, ins(seg, fill(o.color, '0 0 1px rgba(0,0,0,.1)')));
		}
		return el;
	},
	opacity: function (el, i, val) {
		if (i < el.childNodes.length) el.childNodes[i].style.opacity = val;
	}
});

/////////////////////////////////////////////////////////////////////////
// VML rendering for IE
/////////////////////////////////////////////////////////////////////////

/**
 * Check and init VML support
 */
!function () {

	function vml(tag, attr) {
		return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr);
	}

	var s = css(createEl('group'), { behavior: 'url(#default#VML)' });

	if (!vendor(s, 'transform') && s.adj) {

		// VML support detected. Insert CSS rule ...
		sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');

		slgSpinner.prototype.lines = function (el, o) {
			var r = o.length + o.width;
			var s = 2 * r;

			function grp() {
				return css(vml('group', { coordsize: s + ' ' + s, coordorigin: -r + ' ' + -r }), { width: s, height: s });
			}

			var margin = -(o.width + o.length) * 2 + 'px';
			var g = css(grp(), { position: 'absolute', top: margin, left: margin });

			var i;

			function seg(i, dx, filter) {
				ins(g,
				  ins(css(grp(), { rotation: 360 / o.lines * i + 'deg', left: ~~dx }),
					ins(css(vml('roundrect', { arcsize: 1 }), {
						width: r,
						height: o.width,
						left: o.radius,
						top: -o.width >> 1,
						filter: filter
					}),
					  vml('fill', { color: o.color, opacity: o.opacity }),
					  vml('stroke', { opacity: 0 }) // transparent stroke to fix color bleeding upon opacity change
					)
				  )
				);
			}

			if (o.shadow) {
				for (i = 1; i <= o.lines; i++) {
					seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');
				}
			}
			for (i = 1; i <= o.lines; i++) seg(i);
			return ins(el, g);
		};
		slgSpinner.prototype.opacity = function (el, i, val, o) {
			var c = el.firstChild;
			o = o.shadow && o.lines || 0;
			if (c && i + o < c.childNodes.length) {
				c = c.childNodes[i + o]; c = c && c.firstChild; c = c && c.firstChild;
				if (c) c.opacity = val;
			}
		};
	}
	else {
		useCssAnimations = vendor(s, 'animation');
	}
}();



angular.module('slgComponents')
.directive('slgButtonSpinner', ['$timeout', '$interval', '$q', function ($timeout, $interval, $q) {
	return {
		restrict: 'A',
		scope: {},
		link: function (scope, element, attr) {
			scope.expanded = false;
			scope.inProcess = false;
			scope.showSuccessIndicator = true;
			scope.errorFieldName = null;

			element.append(angular.element("<div id='slgButtonSpinner_spinner_" + scope.$id + "' class='slgButtonSpinner_spinner'></div>"));
			element.append(angular.element("<div id='slgButtonSpinner_check_" + scope.$id + "' class='slgButtonSpinner_check'><i class='fa fa-check-circle-o'></i></div>"));
			element.append(angular.element("<div id='slgButtonSpinner_error_" + scope.$id + "' class='slgButtonSpinner_error'><i class='fa fa-times-circle-o'></i></div>"));

			scope.$watch('$parent.' + attr["slgButtonSpinner"], function (newVal, oldVal) {
				if (oldVal === newVal)
					return;

				var status = (newVal) ? newVal.toLowerCase() : "";

				switch (status) {
					case "showspinner":
						element[0].disabled = true;

						scope.waitToShowSpinner = $timeout(function () {
							expand().then(function () {
								showSpinner();
							})
						}, 100)
						break;

					case "hidespinner":
						element[0].disabled = false;

						hideSpinner();
						collapse();
						break;

					case "showok":
						element[0].disabled = false;

						hideSpinner();

						var okCheckDiv = document.getElementById("slgButtonSpinner_check_" + scope.$id);
						okCheckDiv.style.display = "inline-block";

						scope.okTimeout = $timeout(function () {
							var okCheckDiv = document.getElementById("slgButtonSpinner_check_" + scope.$id);
							okCheckDiv.style.display = "none";
							collapse();
						}, 3000);

						break;

					case "showerror":
						hideSpinner();
						element[0].disabled = false;

						$timeout.cancel(scope.okTimeout);
						var okCheckDiv = document.getElementById("slgButtonSpinner_check_" + scope.$id);
						okCheckDiv.style.display = "none";

						var errorDiv = document.getElementById("slgButtonSpinner_error_" + scope.$id);
						errorDiv.style.display = "inline-block";
						break;

					case "reset":
					default:
						hideSpinner();

						var okCheckDiv = document.getElementById("slgButtonSpinner_check_" + scope.$id);
						okCheckDiv.style.display = "none";

						var errorDiv = document.getElementById("slgButtonSpinner_error_" + scope.$id);
						errorDiv.style.display = "none";

						collapse().then(function () {
							element[0].disabled = false;
						})

						break;
				}
			});

			function expand() {
				$timeout.cancel(scope.okTimeout);
				var okCheckDiv = document.getElementById("slgButtonSpinner_check_" + scope.$id);
				okCheckDiv.style.display = "none";

				var errorDiv = document.getElementById("slgButtonSpinner_error_" + scope.$id);
				errorDiv.style.display = "none";

				if (scope.$parent[attr["slgButtonSpinnerError"]])
					scope.$parent[attr["slgButtonSpinnerError"]] = null;

				if (scope.expanded === true)
					return $q.when();

				var deferred = $q.defer();

				waitForInProcessToFinish().then(function () {
					scope.inProcess = true;
					scope.expanded = true;

					// default button
					var expandPixels = 4;

					if (element[0].className.toLowerCase().indexOf("btn-xs") >= 0)
						expandPixels = 3.5;
					else if (element[0].className.toLowerCase().indexOf("btn-sm") >= 0)
						expandPixels = 4;
					else if (element[0].className.toLowerCase().indexOf("btn-xl") >= 0)
						expandPixels = 5;

					scope.originalPadding = parseInt(slgGetStyle(element[0], "padding-right").replace('px', ''));
					var nextPadding = scope.originalPadding;

					var count = 40;
					var boingInterval = $interval(function () {
						if (count > 32) {
							nextPadding = nextPadding - 1;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else if (count > 24) {
							// do nothing
						}
						else if (count > 14) {
							nextPadding = nextPadding + expandPixels;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else if (count > 10) {
							// do nothing
						}
						else if (count > 0) {
							nextPadding = nextPadding - 1;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else {

							$interval.cancel(boingInterval);
							scope.inProcess = false;

							deferred.resolve();							
						}

						count--;
					}, 10);
				})

				return deferred.promise;
			}

			function collapse() {
				if (scope.expanded === false)
					return $q.when();

				var deferred = $q.defer();

				waitForInProcessToFinish().then(function () {
					scope.inProcess = true;
					scope.expanded = false;

					var spinnerDiv = document.getElementById("slgButtonSpinner_spinner_" + scope.$id);
					spinnerDiv.style.display = "none";

					// default button
					var expandPixels = 4;

					if (element[0].className.toLowerCase().indexOf("btn-xs") >= 0)
						expandPixels = 3.5;
					else if (element[0].className.toLowerCase().indexOf("btn-sm") >= 0)
						expandPixels = 4;
					else if (element[0].className.toLowerCase().indexOf("btn-xl") >= 0)
						expandPixels = 5;

					var nextPadding = parseInt(slgGetStyle(element[0], "padding-right").replace('px', ''));

					var count = 40;
					var boingInterval = $interval(function () {
						if (count > 32) {
							nextPadding = nextPadding + 1;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else if (count > 24) {
							// do nothing
						}
						else if (count > 14) {
							nextPadding = nextPadding - expandPixels;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else if (count > 10) {
							// do nothing
						}
						else if (count > 0) {
							nextPadding = nextPadding + 1;
							element[0].style.paddingRight = nextPadding + "px";
						}
						else {
							$interval.cancel(boingInterval);
							scope.inProcess = false;

							deferred.resolve();
						}

						count--;
					}, 10);
				});

				return deferred.promise;
			}

			function showSpinner() {
				var opts = {
					color: "#fff",
					radius: 4,
					length: 4,
					width: 2
				}

				
				if (element[0].className.toLowerCase().indexOf("btn-xs") >= 0) {
					opts.radius = 3;
					opts.length = 3;
					opts.width = 1;
				}
				else if (element[0].className.toLowerCase().indexOf("btn-sm") >= 0) {
					opts.radius = 3;
					opts.length = 4;
					opts.width = 2;
				}
				else if (element[0].className.toLowerCase().indexOf("btn-xl") >= 0) {
					opts.radius = 5;
					opts.length = 5;
					opts.width = 2;
				}

				var spinnerDiv = document.getElementById("slgButtonSpinner_spinner_" + scope.$id);
				spinnerDiv.style.display = "inline-block";
				var spinner = new slgSpinner(opts).spin(spinnerDiv);
			}

			function hideSpinner() {
				var spinnerDiv = document.getElementById("slgButtonSpinner_spinner_" + scope.$id);
				spinnerDiv.style.display = "none";
			}

			function waitForInProcessToFinish() {
				if (scope.inProcess === false)
					return $q.when();

				var deferred = $q.defer();

				var infiniteLoopCheck = 100;
				var waitingInterval = $interval(function () {
					if (scope.inProcess === false || (infiniteLoopCheck-- <= 0)) {
						$interval.cancel(waitingInterval);
						if (infiniteLoopCheck <= 0)
							console.log("slgButtonSpinner wait failed");

						deferred.resolve();
					}
				}, 50);

				return deferred.promise;
			}

			scope.$on("$destroy", function () {
				$timeout.cancel(scope.waitToShowSpinner);
				$timeout.cancel(scope.okTimeout);
			});
		}
	}
}]);
angular.module('slgComponents')
.directive('slgAutoComplete', ['$timeout', '$interval', '$compile', function ($timeout, $interval, $compile) {
	return {
		restrict: 'A',
		scope: {
			ngModel: "=",
			selectedModel: "=?slgAutoCompleteSelectedModel",
			getUrl: "@?slgAutoCompleteGetUrl",
			items: "=?slgAutoCompleteItems",
			minChars: "=?slgAutoCompleteMinChars",
			allowFreeFormText: "=?slgAutoCompleteAllowFreeFormText",
			delay: "=?slgAutoCompleteDelay",
			width: "@?slgAutoCompleteWidth",
			height: "@?slgAutoCompleteHeight",
			ngMouseover: "&?",
			listTextFormatter: "&?slgAutoCompleteListTextFormatter",
			listHtmlFormatter: "&?slgAutoCompleteListHtmlFormatter",
			textboxFormatter: "&?slgAutoCompleteTextboxFormatter"
		},
		require: 'ngModel',
		link: function (scope, element, attrs, ngModelCtrl) {
			if (!attrs["id"])
				element[0].setAttribute('id', 'slgAutoComplete_textbox_' + scope.$id);

			scope.textboxId = element.attr("id");

			var timeout = 100;
			scope.waitForAutoCompleteToRender = $interval(function () {
				var slgAutoCompleteElement = document.getElementById('slgAutoComplete_' + scope.$id);

				if (slgAutoCompleteElement || timeout <= 0) {
					$interval.cancel(scope.waitForAutoCompleteToRender);

					if (timeout === 0) {
						console.log("Element not found");
						return;
					}

					if (scope.height)
						slgAutoCompleteElement.style.maxHeight = scope.height;
					else
						slgAutoCompleteElement.style.maxHeight = "200px";

					if (scope.width) {
						slgAutoCompleteElement.style.width = scope.width;
						slgAutoCompleteElement.style.minWidth = scope.width;
					}
					else {
						var textboxWidth = element.prop('offsetWidth');
						scope.resize();

						scope.resizeEvent = window.addEventListener('resize', scope.resize, false);
					}
				}
			}, 50);

			scope.resize = function () {
				if (!scope.width) {
					var textboxWidth = element.prop('offsetWidth');
					document.getElementById('slgAutoComplete_' + scope.$id).style.width = textboxWidth + "px";
					document.getElementById('slgAutoComplete_' + scope.$id).style.minWidth = textboxWidth + "px";
				}
			}

			document.addEventListener('click', hideList, false);
			function hideList(e) {
				$timeout(function () {
					var el = angular.element(e.target);

					// If they clicked on this textbox, don't hide the list
					if (el.attr("id") === scope.textboxId) {
						return;
					}

					// If they clicked on the li, get the underlying ul and check for the id
					el = angular.element(el[0].parentNode);
					if (el.attr("id") === 'slgAutoComplete_' + scope.$id)
						return;

					scope.visible = false;


					if (scope.allowFreeFormText === true) {
					}
					else {
						if (scope.selectedModel) {
							scope.ngModel = scope.textboxFormatter({ item: scope.selectedModel });
						}
						else {
							scope.ngModel = null;
						}
					}
				})
			}

			var html =
				"<ul ng-show='visible' ng-mouseout='selectedIndex = -1;' id='slgAutoComplete_{{$id}}' class='slgAutoComplete list-group'> " +
				"	<li id='slg_{{$index}}' data-index='{{$index}}' ng-repeat='item in visibleListItems' ng-mouseover='onMouseOver()' class='list-group-item list-group-item-action' ng-class='{ \"active\" : selectedIndex === $index }' ng-click='onClick($index)' ng-bind-html='item.text | toTrusted'>{{item.text}}</li>" +
				"</ul>";


			var compiled = $compile(html)(scope);
			element.after(compiled);

			element.bind('keydown', function (e) {
				$timeout(function () {
					// down arrow
					if (e.which === 40) {
						if (!scope.visibleListItems || scope.visibleItems.length === 0)
							return;

						scope.visible = true;

						scope.selectedIndex++;

						if (scope.selectedIndex >= scope.visibleListItems.length - 1)
							scope.selectedIndex = scope.visibleListItems.length - 1;

						scrollIntoView();
					}
					else if (e.which === 38) {
						if (!scope.visibleListItems || scope.visibleItems.length === 0)
							return;

						scope.visible = true;

						scope.selectedIndex--;

						if (scope.selectedIndex < 0)
							scope.selectedIndex = 0;

						scrollIntoView();
					}
					else if (e.which === 9) {
						if (!element.val()) {
							$timeout.cancel(scope.delayTimeout);
							scope.visible = false;
							return;
						}

						if (scope.allowFreeFormText === true && scope.selectedIndex === -1) {
							$timeout.cancel(scope.delayTimeout);
							//scope.selectedModel = null;
							scope.visible = false;
							scope.selectedIndex = -1;
							return;
						}

						if (scope.delayTimeout || scope.loadingData === true)
							scope.selectFirstItemAfterLoad = true;
						else
							scope.onClick((scope.selectedIndex === -1) ? 0 : scope.selectedIndex);
					}
					else if (e.which === 13) {
						if (scope.selectedIndex === -1)
							return;

						// If we're still loading the data, but 
						if (scope.loadingData === true)
							return;
						else {
							scope.onClick((scope.selectedIndex === -1) ? 0 : scope.selectedIndex);
						}
					}
					else if (e.which === 8 || e.which === 46) {
						$timeout.cancel(scope.delayTimeout);

						scope.delayTimeout = $timeout(function () {
							scope.delayTimeout = null;

							scope.refreshList();
						}, scope.delay);
					}
					else if (e.which === 27) {
						if (scope.selectedIndex > -1)
							scope.selectedIndex = -1;
						else
							scope.visible = false;
					}
				})
			});

			function scrollIntoView() {
				var slgAutoCompleteElement = document.getElementById('slgAutoComplete_' + scope.$id);

				var selectedItem = slgAutoCompleteElement.querySelectorAll("[data-index='" + scope.selectedIndex + "']")[0];

				var scrollTop = slgAutoCompleteElement.scrollTop;
				var scrollBottom = slgAutoCompleteElement.scrollTop + slgAutoCompleteElement.clientHeight;

				var liTop = selectedItem.offsetTop;
				var liBottom = liTop + selectedItem.clientHeight;

				if (liTop < scrollTop)
					slgAutoCompleteElement.scrollTop = selectedItem.offsetTop;
				else if (liBottom > scrollBottom)
					slgAutoCompleteElement.scrollTop += selectedItem.clientHeight + 1;

			}

			element.bind('keypress', function (e) {
				if (e.which === 13)
					return;

				$timeout.cancel(scope.delayTimeout);

				scope.delayTimeout = $timeout(function () {
					scope.delayTimeout = null;

					scope.refreshList();
				}, scope.delay);
			});

			element.bind('focus', function (e) {
				$timeout(function () {
					scope.selectFirstItemAfterLoad = false;

					if (!scope.visibleListItems || scope.visibleItems.length === 0)
						return;

					if (!element.val() || element.val() === '') {
						scope.selectedIndex = -1;
						scope.visibleListItems = null;
						scope.visible = false;
						return;
					}
				})
			});


			scope.$on("$destroy", function () {
				element.unbind('keypress');
				window.removeEventListener('resize', scope.resize, false);
				document.removeEventListener('click', hideList, false);
			})
		},
		controller: ['$scope', '$interval', '$http', '$q', '$sce', function ($scope, $interval, $http, $q, $sce) {
			$scope.delay = $scope.delay || 300;
			$scope.minChars = $scope.minChars || 3;
			$scope.height = $scope.height || "200px";
			$scope.allowFreeFormText = $scope.allowFreeFormText || false;
			$scope.loadingData = false;
			$scope.selectedIndex = -1;
			$scope.selectFirstItemAfterLoad = false;
			$scope.visible = false;

			$scope.onMouseOver = function (idx) {
				if ($scope.ngMouseover)
					$scope.ngMouseover({ idx: idx, item: $scope.visibleItems[idx] });
			}

			$scope.onClick = function (idx) {
				$scope.visible = false;

				if (idx === -1 || (!$scope.visibleItems || $scope.visibleItems.length === 0)) {
					if ($scope.selectedModel && $scope.textboxFormatter) {
						$scope.ngModel = $scope.textboxFormatter({ item: $scope.selectedModel });
					}
					else
						$scope.ngModel = null;

					return;
				}

				if ($scope.selectedModel !== undefined)
					$scope.selectedModel = $scope.visibleItems[idx];

				if ($scope.textboxFormatter) {
					$scope.ngModel = $scope.textboxFormatter({ item: $scope.visibleItems[idx] });
				}
			}

			$scope.$watch("selectedModel", function () {
				if ($scope.selectedModel === null || $scope.selectedModel === undefined) {
					if ($scope.allowFreeFormText === false)
						$scope.ngModel = null;
				}
				else {
					if ($scope.textboxFormatter) {
						$scope.ngModel = $scope.textboxFormatter({ item: $scope.selectedModel });
					}
				}
			});

			$scope.$watch('items', function () {
				$scope.allItems = $scope.items;
			});

			$scope.refreshList = function () {
				$scope.visibleItems = [];
				$scope.visibleListItems = [];

				var searchText = document.getElementById($scope.textboxId).value;

				if (!searchText || searchText === '') {
					$scope.visible = false;
					$scope.selectedModel = null;
					return;
				}

				getItems(searchText).then(function (items) {
					$scope.allItems = items;

					$scope.formattedItems = [];

					var exactMatchAtFirstItems = [];
					var exactMatchAtFirstListItems = [];
					var exactMatchItems = [];
					var exactMatchListItems = [];
					var partialMatchItems = [];
					var partialMatchListItems = [];
					var searchTerms = searchText.split(' ');

					angular.forEach($scope.allItems, function (item) {
						if ($scope.listTextFormatter) {
							var formattedString = $scope.listTextFormatter({ item: item });

							if (formattedString.replace(/["']/g, "").toLowerCase().indexOf(searchText.replace(/["']/g, "").toLowerCase()) >= 0) {
								var index = formattedString.replace(/["']/g, "").toLowerCase().indexOf(searchText.toLowerCase());
								var length = searchText.length;

								// see if there was a single quote
								var hasSingleQuote = formattedString.substring(0, index + length + 1).indexOf("'") > 0;

								if (hasSingleQuote)
									length++;

								if (index === 0) {
									var exactMatchAtFirstStringStart = formattedString.substring(0, index);
									var exactMatchAtFirstStringMiddle = formattedString.substring(index, index + length);
									var exactMatchAtFirstStringEnd = formattedString.substring(index + length, formattedString.length);

									var exactMatchAtFirstString = exactMatchAtFirstStringStart + "<span class='slgAutoCompleteHighlight'>" + exactMatchAtFirstStringMiddle + "</span>" + exactMatchAtFirstStringEnd;
									exactMatchAtFirstItems.push(item);
									exactMatchAtFirstListItems.push(exactMatchAtFirstString);
								}
								else {
									var exactMatchStringStart = formattedString.substring(0, index);
									var exactMatchStringMiddle = formattedString.substring(index, index + length);
									var exactMatchStringEnd = formattedString.substring(index + length, formattedString.length);

									var exactMatchString = exactMatchStringStart + "<span class='slgAutoCompleteHighlight'>" + exactMatchStringMiddle + "</span>" + exactMatchStringEnd;
									exactMatchItems.push(item);
									exactMatchListItems.push(exactMatchString);
								}
							}
							else {
								var searchTerms = searchText.toLowerCase().split(' ');

								var highlightedString = ''

								var highlightPositions = [];

								angular.forEach(searchTerms, function (searchTerm, index) {
									var lowercaseString = formattedString.toLowerCase();
									var currentIndex = 0;
									var infiniteLoopCheck = 10;

									while (lowercaseString.replace(/["']/g, "").indexOf(searchTerm.replace(/["']/g, ""), currentIndex) >= 0 && --infiniteLoopCheck > 0) {
										currentIndex = lowercaseString.replace(/["']/g, "").indexOf(searchTerm.replace(/["']/g, ""), currentIndex);

										// see if there was a single quote
										var hasSingleQuote = lowercaseString.substring(currentIndex, currentIndex + searchTerm.length + 1).indexOf("'") > 0;
										if (hasSingleQuote) {
											highlightPositions.push({ index: currentIndex, length: searchTerm.length + 1 });
											currentIndex += 2;	// If we leave it at the current position, it will just keep finding the same item
										}
										else {
											highlightPositions.push({ index: currentIndex, length: searchTerm.length });
											currentIndex++;	// If we leave it at the current position, it will just keep finding the same item
										}
									}
								});

								if (highlightPositions.length > 0) {
									highlightPositions.sort(function (a, b) { return (a.index === b.index) ? (a.length > b.length) ? 1 : (a.length < b.length) ? -1 : 0 : (a.index > b.index) ? 1 : ((b.index > a.index) ? -1 : 0); });

									var tempArray = [];
									angular.forEach(highlightPositions, function (element, index) {
										tempArray.push(highlightPositions[index])

										if (index > 0) {
											var previousIndex = highlightPositions[index - 1].index;
											var previousLength = highlightPositions[index - 1].length;
											var thisIndex = highlightPositions[index].index;
											var thisLength = highlightPositions[index].length;

											// If the strings are something like this...  ABCDEFG [ABCDE] and [BCD], the BCD is inside the ABCDE, so just leave it alone.
											// Else, it will be something like [ABCD] and [CDEF].  We need to move the length to include the EF
											if (previousIndex + previousLength > thisIndex) {
												// remove the last one added since we are combining them
												tempArray.pop(tempArray.length - 1);
												if (thisIndex + thisLength > previousIndex + previousLength)
													tempArray[tempArray.length - 1].length = ((thisIndex + thisLength) - previousIndex);
											}
										}
									});

									highlightPositions = tempArray;

									angular.forEach(highlightPositions, function (position, index) {
										if (index === 0)
											highlightedString = formattedString.substring(0, highlightPositions[0].index);
										else
											highlightedString += formattedString.substring(highlightPositions[index - 1].index + highlightPositions[index - 1].length, highlightPositions[index].index);
										highlightedString += "<span class='slgAutoCompleteHighlight'>";
										highlightedString += formattedString.substring(position.index, position.index + position.length);
										highlightedString += "</span>";
									});

									highlightedString += formattedString.substring(highlightPositions[highlightPositions.length - 1].index + highlightPositions[highlightPositions.length - 1].length, formattedString.length);
									partialMatchItems.push(item);
									partialMatchListItems.push(highlightedString);
								}
							}
						}
					});

					$scope.visibleItems = $scope.visibleItems.concat(exactMatchAtFirstItems);
					$scope.visibleItems = $scope.visibleItems.concat(exactMatchItems);
					$scope.visibleItems = $scope.visibleItems.concat(partialMatchItems);


					angular.forEach(exactMatchAtFirstListItems, function (item) {
						$scope.visibleListItems.push({
							id: slgGuid(),
							text: item
						});
					})

					angular.forEach(exactMatchListItems, function (item) {
						$scope.visibleListItems.push({
							id: slgGuid(),
							text: item
						});
					})

					angular.forEach(partialMatchListItems, function (item) {
						$scope.visibleListItems.push({
							id: slgGuid(),
							text: item
						});
					})

					if ($scope.listHtmlFormatter) {
						angular.forEach($scope.visibleListItems, function (li, idx) {
							li.text = $scope.listHtmlFormatter({ html: li.text, item: $scope.visibleItems[idx] });
						});
					}

					$scope.resize();
					$scope.visible = $scope.visibleItems.length > 0;
					$scope.selectedIndex = ($scope.visibleItems.length > 0) ? 0 : -1;

					if ($scope.allowFreeFormText == true) {
						$scope.selectedIndex = -1;
						var activeElement = angular.element(document.activeElement);
						if (activeElement.attr('id') !== $scope.textboxId)
							$scope.visible = false;

						return;
					}

					if ($scope.selectFirstItemAfterLoad === true) {
						$scope.selectFirstItemAfterLoad = false;

						if ($scope.allowFreeFormText === true && $scope.visibleItems.length === 0) {
							$scope.selectedModel = null;
							$scope.visible = false;
							return;
						}

						$scope.selectedIndex = 0;
						$scope.onClick(0);
						return;
					}
				})
			}

			function getItems(searchText) {
				if (searchText.length < $scope.minChars)
					return $q.when($scope.allItems);

				if ($scope.items)
					return $q.when($scope.items);

				else if ($scope.getUrl) {
					var deferred = $q.defer();

					$scope.loadingData = true;

					var url = $scope.getUrl;
					if (url.indexOf("?") > 0)
						url += "&searchText=" + searchText;
					else
						url += "?searchText=" + searchText;

					$http.get(url)
					    .then(function (response) {
					    	$scope.loadingData = false;
					    	deferred.resolve(response.data);
					    },
						function (response) {
							console.log(response);
						}
					);

					return deferred.promise;
				}
			}

			function hideList() {

			}
		}]
	}
}])
.filter("toTrusted", ['$sce', function ($sce) {
	return function (text) {
		return $sce.trustAsHtml(text);
	}
}]);

angular.module('slgComponents')
 .service("slgPleaseWaitSvc", ['$timeout', function ($timeout) {
 	var slgPleaseWaitModel = { count: 0, spinner: null, slgPleaseWaitTimeout: null, safetyTimeout: null };

 	var el = angular.element("<div id='slgPleaseWaitOverlay'><div id='slgPleaseWaitSpinner'></div></div>");
 	document.body.appendChild(el[0]);

 	var opts = {
 		lines: 13, // The number of lines to draw
 		length: 15, // The length of each line
 		width: 10, // The line thickness
 		radius: 20, // The radius of the inner circle
 		corners: 1, // Corner roundness (0..1)
 		rotate: 0, // The rotation offset
 		direction: 1, // 1: clockwise, -1: counterclockwise
 		color: '#fff', // #rgb or #rrggbb or array of colors
 		speed: 1, // Rounds per second
 		trail: 60, // Afterglow percentage
 		shadow: false, // Whether to render a shadow
 		hwaccel: false, // Whether to use hardware acceleration
 		zIndex: 2e9 // The z-index (defaults to 2000000000)
 	};

 	slgPleaseWaitModel.spinner = new slgSpinner(opts).spin(document.getElementById('slgPleaseWaitSpinner'));

 	function show(timeoutDelay) {
 		timeoutDelay = (timeoutDelay === null || timeoutDelay === undefined) ? 300 : timeoutDelay;

 		if (slgPleaseWaitModel.count === 0) {
 			slgPleaseWaitModel.safetyTimeout = $timeout(function () { hidePleaseWait_Internal(); }, 10000);

 			slgPleaseWaitModel.slgPleaseWaitTimeout = $timeout(function () {
 				showPleaseWait_Internal();
 			}, timeoutDelay);
 		}

 		slgPleaseWaitModel.count++;
 	}

 	function forceShow() {
 		showPleaseWait_Internal();
 	}

 	function forceHide() {
 		slgPleaseWaitModel.count = 0;
		hidePleaseWait_Internal();
 	}

 	function hide() {
 		if (slgPleaseWaitModel.count === 0)
 			return;

 		slgPleaseWaitModel.count--;

 		if (slgPleaseWaitModel.count === 0)
 			hidePleaseWait_Internal();
 	}

 	function showPleaseWait_Internal() {
 		var element = document.getElementById("slgPleaseWaitOverlay");

 		element.style.display = 'inline-block';
 	}

 	function hidePleaseWait_Internal() {
 		var element = document.getElementById("slgPleaseWaitOverlay");

 		element.style.display = "none";
 		$timeout.cancel(slgPleaseWaitModel.slgPleaseWaitTimeout);
 		$timeout.cancel(slgPleaseWaitModel.safetyTimeout);
 	}

 	return {
 		show: show,
 		hide: hide,
 		forceShow: forceShow,
 		forceHide: forceHide
 	}
 }]);

angular.module('slgComponents')
.directive('slgTabs', ['$timeout', '$interval', '$compile', function ($timeout, $interval, $compile) {
    return {
        restrict: 'E',
        scope: {
            tabNames: "=",
            selectedIndex: "=?",
            onTabSelected_Callback: "&?onTabSelected"
        },
        template: "<div id='slgTabs_{{$id}}' class='slgTabs'>" +
                  "    <button ng-click='onClick($index)' ng-repeat='name in tabNames_Internal' ng-class='{ \"btn-success\": selectedIndex === $index }' class='btn btn-primary' ng-bind-html='name'></button>" +
                  "</div>",
        controller: ['$scope', '$sce', function ($scope, $sce) {
            if (!$scope.selectedIndex)
                $scope.selectedIndex = 0;

            $scope.$watch('tabNames', function () {
                $scope.tabNames_Internal = [];

                if ($scope.tabNames) {
                    angular.forEach($scope.tabNames, function (name) {
                        tabNameSafe = $sce.trustAsHtml(name);
                        $scope.tabNames_Internal.push(tabNameSafe);
                    })
                }
            });

            $scope.onClick = function (index) {
                $scope.selectedIndex = index;

                if ($scope.onTabSelected_Callback)
                    $scope.onTabSelected_Callback({ index: index });
            }
        }]
    }
}]);


//# sourceMappingURL=slgComponents.min.js.map
